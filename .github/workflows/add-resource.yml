name: üöÄ Auto-Add Resource v2

on:
  issues:
    types: [labeled]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  add-resource:
    runs-on: ubuntu-latest
    
    steps:
      - name: üîç Debug event information
        run: |
          echo "=== Event Debug Information ==="
          echo "Event name: ${{ github.event_name }}"
          echo "Action: ${{ github.event.action }}"
          echo "Label name: '${{ github.event.label.name }}'"
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue title: ${{ github.event.issue.title }}"
          echo "Issue labels:"
          echo '${{ toJSON(github.event.issue.labels) }}'
          echo "=============================="
          
      - name: ‚úã Check if we should proceed
        run: |
          if [[ "${{ github.event.action }}" != "labeled" ]]; then
            echo "‚ùå Skipping: Action is '${{ github.event.action }}', not 'labeled'"
            exit 1
          fi
          
          if [[ "${{ github.event.label.name }}" != "approved" ]]; then
            echo "‚ùå Skipping: Label is '${{ github.event.label.name }}', not 'approved'"
            exit 1
          fi
          
          # Accept both [Resource] and [Batch] format issues
          if [[ "${{ github.event.issue.title }}" != *"[Resource]"* && "${{ github.event.issue.title }}" != *"[Batch]"* ]]; then
            echo "‚ùå Skipping: Issue title doesn't contain [Resource] or [Batch]"
            exit 1
          fi
          
          echo "‚úÖ Proceeding: Action is 'labeled', label is 'approved', and issue is resource submission"
          
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PERSONAL_GITHUB_TOKEN }}
          fetch-depth: 0
          
      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: üì¶ Install dependencies
        run: |
          pip install pyyaml
          
      - name: üîß Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
      - name: üîç Debug Git and Token permissions
        run: |
          echo "Git config:"
          git config --list
          echo "Current branch:"
          git branch
          echo "Remote:"
          git remote -v
          echo "Token permissions test:"
          curl -H "Authorization: token $PERSONAL_GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/$GITHUB_REPOSITORY
        env:
          PERSONAL_GITHUB_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}
          
      - name: üìã Parse issue and extract resource data
        id: parse-issue
        run: |
          python3 << 'EOF'
          import os
          import re
          import json
          import yaml
          
          # Get issue body from environment
          issue_body = """${{ github.event.issue.body }}"""
          issue_number = "${{ github.event.issue.number }}"
          issue_title = "${{ github.event.issue.title }}"
          
          print("=== Issue Body ===")
          print(issue_body)
          print("==================")
          
          # Determine if this is batch format or single resource format
          def extract_field(body, field_name):
              pattern = rf"### {field_name}.*?\n\s*\n(.*?)(?=\n\s*\n###|\n\s*\n---|\Z)"
              match = re.search(pattern, body, re.DOTALL | re.IGNORECASE)
              if match:
                  value = match.group(1).strip()
                  if value == "_No response_":
                      return ""
                  return value
              return ""
          
          # Check if this is batch format (has YAML section)
          yaml_section = extract_field(issue_body, "Resources YAML")
          
          if yaml_section and yaml_section.strip():
              print("=== Processing Batch Format ===")
              # Extract YAML from code block
              yaml_match = re.search(r'```yaml\s*\n(.*?)\n```', yaml_section, re.DOTALL)
              if yaml_match:
                  yaml_content = yaml_match.group(1)
              else:
                  yaml_content = yaml_section
              
              print("=== YAML Content ===")
              print(yaml_content)
              print("====================")
              
              # Parse YAML resources
              try:
                  resources_data = yaml.safe_load(yaml_content)
                  if isinstance(resources_data, list):
                      resources = resources_data
                  else:
                      print("‚ùå YAML content is not a list")
                      exit(1)
              except yaml.YAMLError as e:
                  print(f"‚ùå YAML parsing error: {e}")
                  exit(1)
              
              # Validate resources
              valid_resources = []
              for i, resource in enumerate(resources):
                  if not isinstance(resource, dict):
                      continue
                  
                  required_fields = ['name', 'url', 'description', 'tags']
                  if all(field in resource and resource[field] for field in required_fields):
                      valid_resources.append(resource)
                      print(f"‚úÖ Resource {i+1}: {resource['name']}")
                  else:
                      print(f"‚ùå Resource {i+1} missing required fields")
              
              if not valid_resources:
                  print("‚ùå No valid resources found")
                  exit(1)
              
              # Generate YAML for all resources with proper indentation
              batch_yaml = ""
              resource_names = []
              for resource in valid_resources:
                  # Format tags as proper YAML array with quotes around each tag
                  tags_yaml = '[' + ', '.join([f'"{tag}"' for tag in resource['tags']]) + ']'
                  yaml_entry = f'  - name: "{resource["name"]}"\n    url: "{resource["url"]}"\n    description: "{resource["description"]}"\n    tags: {tags_yaml}\n    \n'
                  batch_yaml += yaml_entry
                  resource_names.append(resource['name'])
              
              yaml_entry = batch_yaml
              resource_count = len(valid_resources)
              main_resource_name = f"{resource_count} Resource{'s' if resource_count > 1 else ''}"
              all_names = ", ".join(resource_names[:3]) + ("..." if len(resource_names) > 3 else "")
              
          else:
              print("=== Processing Single Resource Format ===")
              # Extract single resource data
              name = extract_field(issue_body, "Resource Name")
              url = extract_field(issue_body, "URL") 
              description = extract_field(issue_body, "Description")
              tags_raw = extract_field(issue_body, "Tags")
              
              # Clean and parse tags
              if tags_raw:
                  tags = [tag.strip() for tag in tags_raw.split(',') if tag.strip()]
              else:
                  tags = []
              
              # Validate required fields
              if not all([name, url, description, tags]):
                  print("‚ùå Missing required fields:")
                  print("Name: " + str(name))
                  print("URL: " + str(url))
                  print("Description: " + str(description))
                  print("Tags: " + str(tags))
                  exit(1)
              
              # Generate YAML entry for single resource with proper indentation
              tags_yaml = '[' + ', '.join([f'"{tag}"' for tag in tags]) + ']'  
              yaml_entry = f'  - name: "{name}"\n    url: "{url}"\n    description: "{description}"\n    tags: {tags_yaml}\n    '
              
              resource_count = 1
              main_resource_name = name
              all_names = name
          
          print("=== Generated YAML ===")
          print(yaml_entry)
          print("======================")
          
          # Write outputs for next steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("resource-name=" + main_resource_name + "\n")
              f.write("resource-names=" + all_names + "\n")
              f.write("resource-count=" + str(resource_count) + "\n")
              f.write("yaml-entry<<EOF\n" + yaml_entry + "\nEOF\n")
              f.write("issue-number=" + issue_number + "\n")
          
          print("‚úÖ Resource data extracted successfully")
          EOF
          
      - name: üìù Add resource to resources.yml
        run: |
          echo "Adding resource to resources.yml..."
          
          # Ensure resources.yml ends with a newline before appending
          echo "" >> resources.yml
          
          # Append the new resource to the end of resources.yml
          cat >> resources.yml << 'EOF'
          ${{ steps.parse-issue.outputs.yaml-entry }}
          EOF
          
          echo "‚úÖ Resource added to resources.yml"
          
      - name: üîÑ Generate README and update resources
        run: |
          echo "Running generate_readme.py..."
          cd scripts
          python3 generate_readme.py
          cd ..
          echo "‚úÖ README and resources updated"
          
      - name: üßπ Clean workspace and prepare files
        run: |
          echo "Resetting all changes first..."
          git reset --hard HEAD
          git clean -fd
          
          echo "Re-adding the resource to resources.yml..."
          # Ensure resources.yml ends with a newline before appending
          echo "" >> resources.yml
          cat >> resources.yml << 'EOF'
          ${{ steps.parse-issue.outputs.yaml-entry }}
          EOF
          
          echo "Re-running generate_readme.py..."
          cd scripts
          python3 generate_readme.py
          cd ..
          
          # Force reset any workflow file changes
          git checkout HEAD -- .github/workflows/ || true
          git reset HEAD -- .github/workflows/ || true
          
          echo "=== Final status check ==="
          git status --porcelain
          echo "=========================="
          
      - name: üîÑ Manual commit and push
        run: |
          # Create new branch
          BRANCH_NAME="add-resource-${{ steps.parse-issue.outputs.issue-number }}"
          git checkout -b $BRANCH_NAME
          
          # Aggressively reset all workflow changes
          echo "Resetting workflow files..."
          git checkout HEAD -- '.github/**' || true
          git reset HEAD -- '.github/**' || true
          git clean -fd .github/ || true
          
          # Check what files have changed after reset
          echo "=== Git Status After Reset ==="
          git status --porcelain
          echo "=============================="
          
          # Stage only the specific files we want to commit, one by one
          echo "Staging target files individually..."
          
          if [ -f "resources.yml" ]; then
            git add resources.yml
            echo "‚úì Staged resources.yml"
          fi
          
          if [ -f "README.md" ]; then
            git add README.md
            echo "‚úì Staged README.md"
          fi
          
          if [ -f "docs/resources.json" ]; then
            git add docs/resources.json
            echo "‚úì Staged docs/resources.json"
          fi
          
          if [ -f "scripts/url_index.json" ]; then
            git add scripts/url_index.json
            echo "‚úì Staged scripts/url_index.json"
          fi
          
          # Final check - make sure no workflow files are staged
          echo "=== Final staged files check ==="
          STAGED_FILES=$(git diff --cached --name-only)
          echo "$STAGED_FILES"
          
          # Abort if any .github files are staged
          if echo "$STAGED_FILES" | grep -q "^\.github/"; then
            echo "‚ùå ERROR: Workflow files detected in staged changes!"
            echo "Staged .github files:"
            echo "$STAGED_FILES" | grep "^\.github/"
            exit 1
          fi
          echo "‚úì No workflow files in staged changes"
          echo "====================================="
          
          # Commit changes
          git commit -m "Add resource: ${{ steps.parse-issue.outputs.resource-name }}

          Resources: ${{ steps.parse-issue.outputs.resource-names }}
          Count: ${{ steps.parse-issue.outputs.resource-count }}

          Auto-generated from issue #${{ steps.parse-issue.outputs.issue-number }}"
          
          # Push branch
          git push https://x-access-token:${{ secrets.PERSONAL_GITHUB_TOKEN }}@github.com/${{ github.repository }} $BRANCH_NAME

          
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT
        env:
          PERSONAL_GITHUB_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}
          
      - name: üìä Create Pull Request via API
        uses: actions/github-script@v7
        with:
          script: |
            const resourceName = `${{ steps.parse-issue.outputs.resource-name }}`;
            const resourceNames = `${{ steps.parse-issue.outputs.resource-names }}`;
            const resourceCount = `${{ steps.parse-issue.outputs.resource-count }}`;
            const issueNumber = `${{ steps.parse-issue.outputs.issue-number }}`;
            const runId = `${{ github.run_id }}`;
            
            const { data: pullRequest } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Add resource: ${resourceName}`,
              head: `add-resource-${issueNumber}`,
              base: "main",
              body: `## üöÄ Auto-generated resource addition
              
              This PR automatically adds ${resourceCount} resource${resourceCount > 1 ? 's' : ''} based on the approved submission in issue #${issueNumber}.
              
              ### üìã Resource Details
              - **Resources**: ${resourceNames}
              - **Count**: ${resourceCount}
              
              ### ‚úÖ Automated Actions Completed
              - [x] ${resourceCount} resource${resourceCount > 1 ? 's' : ''} added to resources.yml
              - [x] README.md regenerated
              - [x] Resources index updated
              - [x] URL validation completed
              
              **Source**: Issue #${issueNumber}
              **Auto-generated**: ${runId}`
            });
            
            console.log('Created PR #' + pullRequest.number);
            
            // Auto-merge the PR since it was generated from an approved issue
            console.log('Auto-merging PR #' + pullRequest.number);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pullRequest.number,
              commit_title: `Add resource: ${resourceName}`,
              commit_message: `Auto-merged from approved issue #${issueNumber}`,
              merge_method: 'squash'
            });
            
            console.log('Successfully auto-merged PR #' + pullRequest.number);
            
            // Delete the branch after successful merge
            console.log('Deleting branch: add-resource-' + issueNumber);
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/add-resource-' + issueNumber
              });
              console.log('Successfully deleted branch: add-resource-' + issueNumber);
            } catch (error) {
              console.log('Warning: Could not delete branch - ' + error.message);
            }
            
            return pullRequest.number;
          
      - name: üìù Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            const resourceCount = `${{ steps.parse-issue.outputs.resource-count }}`;
            const resourceNames = `${{ steps.parse-issue.outputs.resource-names }}`;
            
            github.rest.issues.createComment({
              issue_number: ${{ steps.parse-issue.outputs.issue-number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## üöÄ Resource${resourceCount > 1 ? 's' : ''} Successfully Added!
              
              ‚úÖ Your ${resourceCount} resource${resourceCount > 1 ? 's have' : ' has'} been automatically processed and **merged into the main collection**!
              
              **Resources added:** ${resourceNames}
              
              **What happened:**
              - ${resourceCount} resource${resourceCount > 1 ? 's' : ''} added to \`resources.yml\`
              - README.md regenerated with all new resources
              - Pull request created and automatically merged
              - Resource${resourceCount > 1 ? 's are' : ' is'} now live in the collection
              
              **Your resource${resourceCount > 1 ? 's are' : ' is'} now available at:**
              - Web interface: [AI Resources Collection](https://baptisteblouin.github.io/AI-resources/)
              - GitHub: [resources.yml](https://github.com/BaptisteBlouin/AI-resources/blob/main/resources.yml)
              
              Thank you for contributing ${resourceCount} resource${resourceCount > 1 ? 's' : ''} to the AI Resources collection! üéâ`
            });
            
            // Close the issue as it's been processed
            github.rest.issues.update({
              issue_number: ${{ steps.parse-issue.outputs.issue-number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['approved', 'processed']
            });